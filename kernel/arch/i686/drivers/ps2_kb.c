#include <drivers/ps2_kb.h>

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#include <stdio.h>

#include <drivers/kb.h>
#include <x86/interrupts.h>
#include <x86/pio.h>

#define IRQ1_KEYBOARD_DATA_READY 1

/* Keyboard controller ports */

#define PS2_KB_DATA 0x60
#define PS2_KB_CMD 0x64
#define PS2_KB_STATUS 0x64

/* Status byte flags */

#define PS2_KB_OUTPUT_BUFFER_STATUS (1 << 0)
#define PS2_KB_INPUT_BUFFER_STATUS (1 << 1)

/* Configuration byte flags */

#define PS2_KB_ENABLE_IRQ1 (1 << 0)
#define PS2_KB_ENABLE_IRQ2 (1 << 1)
#define PS2_KB_TRANSLATE (1 << 6)

/* Keyboard controller commands */

#define PS2_KB_GETCONFIG 0x20
#define PS2_KB_SETCONFIG 0x60
#define PS2_KB_DISABLE2 0xa7
#define PS2_KB_CONTROLLER_SELF_TEST 0xaa
#define PS2_KB_DISABLE1 0xad
#define PS2_KB_ENABLE1 0xae

/* Controller response */

#define PS2_KB_CONTROLLER_SELF_TEST_PASSED 0x55

/* Device commands (sent on the data port!) */

#define PS2_KB_SETSCANCODESET 0xf0
#define PS2_KB_RESET 0xff

/* Device response */

#define PS2_KB_SELF_TEST_PASSED 0xaa
#define PS2_KB_ACK 0xfa
#define PS2_KB_RESEND 0xfe

static uint8_t scancode_set;

/* Translation tables from the various scancode sets to key codes. */

static uint8_t scs2_keycodes[2][256] = {{
    /* F7 is 0x83 according to the spec but 0x02 on my machine? */
    0xff, 0x09, 0x07, 0x05, 0x03, 0x01, 0x02, 0x0c, 0xff, 0x0a, 0x08, 0x06,
    0x04, 0x40, 0x20, 0xff, 0xff, 0xa2, 0x80, 0xff, 0xa0, 0x41, 0x21, 0xff,
    0xff, 0xff, 0x81, 0x62, 0x61, 0x42, 0x22, 0xff, 0xff, 0x83, 0x82, 0x63,
    0x43, 0x24, 0x23, 0xff, 0xff, 0xa3, 0x84, 0x64, 0x45, 0x44, 0x25, 0xff,
    0xff, 0x86, 0x85, 0x66, 0x65, 0x46, 0x26, 0xff, 0xff, 0xff, 0x87, 0x67,
    0x47, 0x27, 0x28, 0xff, 0xff, 0x88, 0x68, 0x48, 0x49, 0x2a, 0x29, 0xff,
    0xff, 0x89, 0x8a, 0x69, 0x6a, 0x4a, 0x2b, 0xff, 0xff, 0xff, 0x6b, 0xff,
    0x4b, 0x2c, 0xff, 0xff, 0x60, 0x8b, 0x6c, 0x4c, 0xff, 0x4d, 0xff, 0xff,
    0xff, 0x91, 0xff, 0xff, 0xff, 0xff, 0x2d, 0xff, 0xff, 0x8d, 0xff, 0x6d,
    0x51, 0xff, 0xff, 0xff, 0xab, 0xac, 0x8e, 0x6e, 0x6f, 0x52, 0x00, 0x31,
    0x0b, 0x54, 0x8f, 0x34, 0x33, 0x53, 0x0e, 0xff, 0xff, 0xff, 0xff, 0x07,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff
}, {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xa4, 0xfe, 0xff, 0xa7, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa1, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xa5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa6,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0x32, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x90, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x4f, 0xff, 0xa8,
    0x2f, 0xff, 0xff, 0xff, 0x2e, 0x4e, 0xa9, 0xff, 0xaa, 0x8c, 0xff, 0xff,
    0xff, 0xff, 0x50, 0xff, 0x0d, 0x30, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff
}};

static uint8_t scs3_keycodes[256] = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0xff, 0xff, 0xff,
    0xff, 0x40, 0x20, 0x02, 0xff, 0xa0, 0x80, 0x91, 0x60, 0x41, 0x21, 0x03,
    0xff, 0xa2, 0x81, 0x62, 0x61, 0x42, 0x22, 0x04, 0xff, 0x83, 0x82, 0x63,
    0x43, 0x24, 0x23, 0x05, 0xff, 0xa3, 0x84, 0x64, 0x45, 0x44, 0x25, 0x06,
    0xff, 0x86, 0x85, 0x66, 0x65, 0x46, 0x26, 0x07, 0xff, 0xa4, 0x87, 0x67,
    0x47, 0x27, 0x28, 0x08, 0xff, 0x88, 0x68, 0x48, 0x49, 0x2a, 0x29, 0x09,
    0xff, 0x89, 0x8a, 0x69, 0x6a, 0x4a, 0x2b, 0x0a, 0xff, 0xff, 0x6b, 0xff,
    0x4b, 0x2c, 0x0b, 0x0d, 0xa7, 0x8b, 0x6c, 0x4c, 0x4d, 0xff, 0x0c, 0x0e,
    0xa9, 0xa8, 0x0f, 0x8c, 0x4e, 0x4f, 0x2d, 0x2e, 0xff, 0x8d, 0xaa, 0x6d,
    0x51, 0x50, 0x2f, 0x30, 0xab, 0xac, 0x8e, 0x6e, 0x6f, 0x52, 0x31, 0xff,
    0xff, 0x90, 0x8f, 0xff, 0x54, 0x53, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa1, 0xa5, 0xa6, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff
};

static bool release_next;
static uint8_t ignore_next;
static uint8_t scancode_plane;

static void wait_out(uint16_t port, uint8_t val)
{
    uint8_t status;
    do {
        status = inb(PS2_KB_STATUS);
    } while (status & PS2_KB_INPUT_BUFFER_STATUS);
    outb(port, val);
}

static uint8_t wait_in()
{
    uint8_t status;
    do {
        status = inb(PS2_KB_STATUS);
    } while (!(status & PS2_KB_OUTPUT_BUFFER_STATUS));
    return inb(PS2_KB_DATA);
}

static uint8_t send_dev_command1(uint8_t command)
{
    uint8_t status;
    do {
        wait_out(PS2_KB_DATA, command);
        status = wait_in();
    } while (status == PS2_KB_RESEND);
    return status;
}

static uint8_t send_dev_command2(uint8_t command, uint8_t arg)
{
    if (send_dev_command1(command) != PS2_KB_ACK) {
        printf("err: ps/2: first byte not ACKed: %02X %02X\n", command, arg);
    }
    return send_dev_command1(arg);
}

static void cfg_set(uint8_t flag)
{
    wait_out(PS2_KB_CMD, PS2_KB_GETCONFIG);
    uint8_t config = wait_in();
    config |= flag;
    wait_out(PS2_KB_CMD, PS2_KB_SETCONFIG);
    wait_out(PS2_KB_DATA, config);
}

static void cfg_clear(uint8_t flag)
{
    wait_out(PS2_KB_CMD, PS2_KB_GETCONFIG);
    uint8_t config = wait_in();
    config &= ~flag;
    wait_out(PS2_KB_CMD, PS2_KB_SETCONFIG);
    wait_out(PS2_KB_DATA, config);
}

static bool controller_setup()
{
    /* Self-test controller. */
    wait_out(PS2_KB_CMD, PS2_KB_CONTROLLER_SELF_TEST);
    if (wait_in() != PS2_KB_CONTROLLER_SELF_TEST_PASSED) {
        printf("err: ps/2: controller self test failed\n");
        return false;
    }

    /* Disable device port 2 (usually the mouse). */
    wait_out(PS2_KB_CMD, PS2_KB_DISABLE1);
    wait_out(PS2_KB_CMD, PS2_KB_DISABLE2);

    /* Disable translation. By default, the keyboard controller translates from
     * the keyboard's native scancode set (usually 2) to set 1 for
     * compatibility reasons. */
    cfg_clear(PS2_KB_ENABLE_IRQ1 | PS2_KB_ENABLE_IRQ2 | PS2_KB_TRANSLATE);

    /* Reset devices. */
    uint8_t response = send_dev_command1(PS2_KB_RESET);
    if (response != PS2_KB_ACK) {
        printf("warn: ps/2: unable to reset devices\n");
    } else if (wait_in() != PS2_KB_SELF_TEST_PASSED) {
        printf("err: ps/2: device self test failed\n");
        return false;
    }

    /* If supported, we want to use set 3, the most modern one and the only one
     * with the reasonable stance of reporting both pressing and releasing on
     * every key, including the Pause key. */
    response = send_dev_command2(PS2_KB_SETSCANCODESET, 3);
    if (response != PS2_KB_ACK) {
        printf("warn: ps/2: unable to set scancode set\n");
    }

    /* Check if it worked. If it didn't, we just have to use whatever the
     * keyboard supports, which SHOULD always be 2, but might be 1? */
    response = send_dev_command2(PS2_KB_SETSCANCODESET, 0);
    if (response != PS2_KB_ACK) {
        printf("err: ps/2: failed to determine scancode set\n");
        return false;
    }
    scancode_set = wait_in();
    if (scancode_set < 1 || scancode_set > 3) {
        printf("err: ps/2: unknown scancode set: %d\n", scancode_set);
        return false;
    }
    printf("info: ps/2: using scancode set %d\n", scancode_set);

    /* Re-enable IRQ1. */
    cfg_set(PS2_KB_ENABLE_IRQ1);

    /* Re-enable device port 1 (keyboard). */
    wait_out(PS2_KB_CMD, PS2_KB_ENABLE1);

    printf("info: ps/2: setup successful\n");
    return true;
}

INTERRUPT_HANDLER(ps2_key_pressed)()
{
    uint8_t scancode;
    scancode = inb(PS2_KB_DATA);

    switch (scancode_set)
    {
    case 3:
        if (scancode == 0xf0) {
            release_next = true;
        } else {
            uint8_t keycode = scs3_keycodes[scancode];
            if (keycode == 0xff) {
                printf("warn: ps/2: unknown scancode: %02X\n", scancode);
            } else {
                if (release_next) {
                    kb_key_released(keycode);
                } else {
                    kb_key_pressed(keycode);
                }
            }
            
            release_next = false;
        }
        break;

    case 2:
        if (scancode == 0xf0) {
            release_next = true;
        } else if (scancode == 0xe0) {
            scancode_plane = 1;
        } else if (scancode == 0xe1) {
            ignore_next = 2;
        } else {
            uint8_t keycode = scs2_keycodes[scancode_plane][scancode];
            if (ignore_next != 0) {
                keycode = 0xfe;
                ignore_next--;
                if (ignore_next == 0) {
                    /* PAUSE */
                    keycode = 0x0f;
                }
            }
            if (keycode == 0xff) {
                printf("warn: ps/2: unknown scancode: %02X\n", scancode);
            } else if (keycode == 0xfe) {
                /* Continue the sequence. Used for scancodes that only occur in
                 * a sequence but don't uniquely identify it (currently only
                 * 0x12) so the sequence doesn't fire multiple times. */
                /* TODO: Checking all keys in a sequence might be necessary for
                 * like Chinese keyboards which may use different sequences? */
            } else {
                if (release_next) {
                    kb_key_released(keycode);
                } else {
                    kb_key_pressed(keycode);
                }
            }
            release_next = false;
            scancode_plane = 0;
        }
        break;
    
    default:
        printf("info: ps/2: scancode set not yet supported\n");
        break;
    }

    pic_eoi(IRQ1_KEYBOARD_DATA_READY);
}

void ps2_kb_driversetup()
{
    if (!controller_setup()) {
        printf("FATAL: ps/2: keyboard will not be available\n");
        return;
    }
    set_isr(IRQ_OFFSET + IRQ1_KEYBOARD_DATA_READY, int_ps2_key_pressed);
    pic_clear_mask(IRQ1_KEYBOARD_DATA_READY);
}

void ps2_kb_drivercleanup()
{
    pic_set_mask(IRQ1_KEYBOARD_DATA_READY);
    set_isr(IRQ_OFFSET + IRQ1_KEYBOARD_DATA_READY, NULL);
}
